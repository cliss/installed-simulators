//
//  main.swift
//  installed-simulators
//
//  Created by Casey Liss on 4/1/22.
//

import Foundation
import ArgumentParser

struct Export: ParsableCommand {
    @Option(help: "The path for the output file.")
    var exportPath: String = "."
    
    @Option(help: "The name of the enum that is output.")
    var typeName: String = "Simulator"
    
    @Option(help: "The path to the xcrun command.")
    var xcrunpath: String = "/usr/bin/xcrun"
    
    static var configuration: CommandConfiguration {
        CommandConfiguration(commandName: "installed-simulators", abstract: "Creates a file that has a series of PreviewContext items, one per installed iOS simulator.")
    }

    func runAsync() async throws {
        let arguments = [
            "simctl",
            "list",
            "devices",
            "available"
        ]
        
        do {
            let rawList = try await run(command: URL(fileURLWithPath: self.xcrunpath),
                                        arguments: arguments)
            let list = process(list: rawList)
            let e = generateEnum(from: list)
            if let data = e.data(using: .utf8) {
                let url = URL(fileURLWithPath: "\(exportPath)/\(self.typeName).swift")
                try data.write(to: url)
                print("Wrote to \(url.absoluteString.replacingOccurrences(of: "file://", with: ""))")
            }
        }
        // No need to catch; it will be reported to the user by the system.
    }
    
    // https://stackoverflow.com/a/67846989/98199
    func run(command: URL, arguments: [String] = []) async throws -> String {
        return try await withCheckedThrowingContinuation { continuation in
            let task = Process()
            task.executableURL = command
            task.arguments = arguments
            
            let outputPipe = Pipe()
            let errorPipe = Pipe()
            
            task.standardOutput = outputPipe
            task.standardError = errorPipe
            
            task.terminationHandler = { process in
                do {
                    let output = try string(from: outputPipe, named: "output")
                    let error = try string(from: errorPipe, named: "error")
                    
                    if
                        let error = error,
                            !error.isEmpty,
                        // Xcode keeps throwing weird errors. Should investigate.
                        !error.contains("Unknown binary with magic")
                    {
                        continuation.resume(throwing: ExportError.commandError(error))
                    } else if let output = output {
                        continuation.resume(returning: output)
                    } else {
                        continuation.resume(throwing: ExportError.noDataReturned)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
            
            do {
                try task.run()
            } catch {
                continuation.resume(throwing: error)
            }
        }
    }
    
    func string(from pipe: Pipe, named: String) throws -> String? {
        do {
            if let data = try pipe.fileHandleForReading.readToEnd() {
                return String(data: data, encoding: .utf8)
            } else {
                return nil
            }
        } catch {
            print("Could not read from \(named) pipe:\n\(error)")
            throw ExportError.couldNotReadFromPipe(named: named, error: error)
        }
    }
    
    func process(list: String) -> [String] {
        let lines = list.split(separator: "\n")
        let simulators = lines.filter { $0.starts(with: "    ") }
        let retVal = simulators.compactMap { sim -> String? in
            // Find the simulator's UUID in the output
            guard let range = sim.range(of: #" \(([A-F]|\d|-)*\)"#, options: .regularExpression) else { return nil }
            // We want everything from the start index â†’ GUID, less the leading/trailing whitespace.
            return sim[sim.startIndex...range.lowerBound].trimmingCharacters(in: .whitespaces)
        }
        return retVal
    }
    
    func generateEnum(from list: [String]) -> String {
        let formatter = DateFormatter()
        formatter.dateStyle = .short
        formatter.timeStyle = .short
        
        var retVal =
        """
        //
        //  \(self.typeName).swift
        //
        //  This file was auto-generated by the installed-simulators tool.
        //  It was generated at \(formatter.string(from: .now)).
        //
        //  For more information, see:
        //    https://github.com/cliss/installed-simulators
        //
        //  *** THIS FILE IS AUTO-GENERATED; PLEASE DO NOT MODIFY IT ***
        
        import SwiftUI
        
        enum \(self.typeName) {
        
        """
        list.forEach { simulator in
            let name = simulator
                .replacingOccurrences(of: #"[\s\(\)\-]+"#, with: "", options: .regularExpression)
                .replacingOccurrences(of: #"[\.]+"#, with: "_", options: .regularExpression)
            retVal += "\tstatic let \(name) = PreviewDevice(rawValue: \"\(simulator)\")\n"
        }
        retVal += "}\n"
        return retVal
    }
}

@main
struct MainApp {
    static func main() async {
        do {
            if let command = try Export.parseAsRoot() as? Export {
                try await command.runAsync()
            }
        } catch {
            Export.exit(withError: error)
        }
    }
}

enum ExportError: LocalizedError {
    case couldNotReadFromPipe(named: String, error: Error)
    case commandError(String)
    case noDataReturned
    
    var errorDescription: String? {
        switch self {
        case let .couldNotReadFromPipe(named, error):
            return "Could not read from \(named) pipe: \(error)"
        case let .commandError(error): return "Error from xcrun: \(error)"
        case .noDataReturned: return "No data was returned from xcrun"
        }
    }
}
